import System.Environment
import qualified Data.Map.Strict as M
import Numeric
import List (nubSort)
import Data.List (groupBy,sort,intersperse)

-- This program composes latex tables from raw data in results files
-- already generated by test runs. Expected command-line arguments are:
-- (1) data directory (2) table header (3) table footer
-- (4) data column number (5) scalar multiplier
-- All data lines start with alphabet size and expression size.
-- Subsequent data columns are indexed from 0.
main = do
    [dataDir, header, footer, c, s] <- getArgs
    let dataCol = read c :: Int
    let scalar  = read s :: Double 
    processDirectory dataDir dataCol $ putTable header footer scalar

type NTable = M.Map Int [Maybe Double]
type State  = ([Int],NTable)

make2D :: [(Int,Int,Double)] -> State
make2D trs = (alphalist, M.fromList pmap)
             where
             alphalist  = nubSort [a | (_,a,_) <- trs]
             pmap = map mapentry $ groupBy (\(x,_,_) (y,_,_) -> x==y) $ sort trs
             mapentry xs@((s,_,_):_) = (s,formList xs alphalist)
             formList [] xs = map (const Nothing) xs
             formList zs@((_,x,y):xs) (al:als)
                 | x==al
                 = Just y : formList xs als
                 | otherwise
                 = Nothing : formList zs als

readTable:: Int -> String -> IO State
readTable dataCol filename = do
    s <- readFile filename
    return $ make2D $ map (tripleFrom dataCol . words) (lines s)

tripleFrom :: Int -> [String] -> (Int,Int,Double)
tripleFrom dataCol (w:s:etc)  =  (read s, read w, read (etc!!dataCol))

filenames, trafonames :: [String]
filenames  = [ "Gruber-Gulan",  "normal",    "fused",         "promoted",
               "stellar",       "pressed",   "synsearch",     "semsearch" ]
trafonames = [ "Gruber-Gulan+", "normalise", "+ fuse",        "+ promote",
               "+ stellate",    "+ press",   "+ syn. search", "+ sem. search" ]

tableEntries :: [String] -> String
tableEntries  =  unwords . intersperse " & "

processDirectory :: String -> Int -> ([NTable] -> String -> Int -> IO()) -> IO()
processDirectory dir col pt  =  do
    statelist <- mapM (readTable col) $ map ((dir ++ "/")++) filenames
    let alplist = fst (head statelist)
    let maplist = map snd statelist
    let sizelist = M.keys (head maplist)
    let alpString = tableEntries $ map show alplist
    mapM_ (pt maplist alpString) sizelist

printFloat :: Maybe Double -> String
printFloat (Just d) = showFFloat (Just 2) d ""
printFloat Nothing  = "--"

putRow :: Double -> (String,[Maybe Double]) -> IO ()
putRow scalar (title,ds)  =  do
    let nds = [printFloat (fmap (scalar*) d) | d <- ds]
    putStr $ tableEntries (title : nds)
    putStrLn " \\\\"

putTable :: String -> String -> Double -> [NTable] -> String -> Int -> IO()
putTable header footer scalar tabs sizes n  =  do
    putStrLn "\\begin{figure}\\begin{tabular}{rrrrrrrrrr}"
    putStrLn $ " & \\multicolumn{9}{c}{" ++ header ++ "} \\\\"
    putStrLn $ sizes ++ " \\\\"
    mapM_ (putRow scalar) (zip trafonames [ t M.! n | t<-tabs])
    putStrLn $ "\\end{tabular}\\caption{"
               ++ footer
               ++ " (alphabet size = " ++ show n ++ ")"
               ++ ".}\\end{figure}"
