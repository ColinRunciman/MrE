import System.Environment
import System.Directory
import qualified Data.Map.Strict as M
import Numeric
import List (nubSort)
import Data.List (groupBy,sort,intersperse)

-- This program composes latex tables from raw data in results files
-- already generated by test runs. Expected command-line arguments are:
-- (1) data directory (2) table header (3) table footer
-- (4) data column number (5) scalar multiplier
-- All data lines start with alphabet size and expression size.
-- Subsequent data columns are indexed from 0.
main = do
    [dataDir, header, footer, c, s] <- getArgs
    let dataCol = read c :: Int
    let scalar  = read s :: Double 
    processDirectory dataDir dataCol $ putTable header footer scalar

type NTable = M.Map Int [Maybe Double]
type State  = ([Int],NTable)

make2D :: [(Int,Int,Double)] -> State
make2D trs = (sizelist, M.fromList pmap)
             where
             sizelist  = nubSort [s | (_,s,_) <- trs]
             pmap = map mapentry $ groupBy (\(x,_,_) (y,_,_) -> x==y) $ sort trs
             mapentry xs@((s,_,_):_) = (s,formList xs sizelist)
             formList [] xs = map (const Nothing) xs
             formList zs@((_,x,y):xs) (s:ss)
                 | x==s
                 = Just y : formList xs ss
                 | otherwise
                 = Nothing : formList zs ss

readTable:: Int -> String -> IO State
readTable dataCol filename = do
    s <- readFile filename
    return $ make2D $ map (tripleFrom dataCol . words) (lines s)

tripleFrom :: Int -> [String] -> (Int,Int,Double)
tripleFrom dataCol (w:s:etc)  =  (read w, read s, read (etc!!dataCol))

filenames, trafonames :: [String]
filenames  = [ "Gruber-Gulan",  "normal",    "fused",         "promoted",
               "stellar",       "pressed",   "synsearch",     "semsearch" ]
trafonames = [ "Gruber-Gulan+", "normalise", "+ fuse",        "+ promote",
               "+ stellate",    "+ press",   "+ syn. search", "+ sem. search" ]

tableEntries :: [String] -> String
tableEntries  =  unwords . intersperse " & "

processDirectory ::
    String -> Int -> ([String] -> [NTable] -> [Int] -> Int -> IO()) -> IO()
processDirectory dir col pt  =  do
    dirListing    <- listDirectory dir
    let ftnames    =  filter (\(f,t) -> f `elem` dirListing) $ zip filenames trafonames
    let (fs,ts)    =  unzip ftnames
    statelist     <-  mapM (readTable col) $ map ((dir ++ "/")++) fs
    let sizelist   =  fst (head statelist)
    let maplist    =  map snd statelist
    let widthlist  =  M.keys (head maplist)
    mapM_ (pt ts maplist sizelist) widthlist

printFloat :: Maybe Double -> String
printFloat (Just d) = showFFloat (Just 2) d ""
printFloat Nothing  = "--"

putRow :: Double -> (String,[Maybe Double]) -> IO ()
putRow scalar (title,ds)  =  do
    let nds = [printFloat (fmap (scalar*) d) | d <- ds]
    putStr $ tableEntries (title : nds)
    putStrLn " \\\\"

putTable :: String -> String -> Double -> [String] -> [NTable] -> [Int] -> Int -> IO()
putTable header footer scalar trafos tabs sizes w  =  do
    let n  =  length sizes
    putStrLn $ "\\begin{figure}[ht]\\begin{tabular}{" ++ replicate (1+n) 'r' ++ "}"
    putStrLn $ " & \\multicolumn{"++show n++"}{c}{" ++ header ++ "} \\\\"
    putStrLn $ tableEntries ("" : map show sizes) ++ " \\\\"
    mapM_ (putRow scalar) (zip trafos [ t M.! w | t<-tabs])
    putStrLn $ "\\end{tabular}\\caption{"
               ++ footer
               ++ " (alphabet size = " ++ show w ++ ")"
               ++ ".}\\end{figure}"
